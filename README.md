# RISC-V Simulator (Phase 2)  

## Project Overview  
The **Phase 2** of the RISC-V Simulator is a C++ program that simulates the execution of RISC-V machine code generated from Phase 1 (RISC-V Assembler). It reads machine code from `input.mc`, executes it step-by-step, and logs the final register and memory state in `output.mc`.  

## Team Details
- **Aadit Mahajan (2023CSB1091)**
- **Aksh Sihag (2023CSB1097)**
- **Rahul Goyal (2023CSB1150)**

---


## Table of Contents  
1. [Installation & Compilation](#1-installation--compilation)  
2. [Usage Instructions](#2-usage-instructions)  
3. [Simulator Workflow](#3-simulator-workflow)  
4. [Supported Instructions](#4-supported-instructions)  
5. [Memory & Register Handling](#5-memory--register-handling)  
6. [Output Format](#6-output-format)  

---

## 1. Installation & Compilation  

### Compiling the Code
```bash
g++ code.cpp -o code
```

### Running the Simulator  
```bash
./code
```
- Reads machine code from input.mc (generated by Phase 1).  
- Outputs final state to output.mc.  

---

### Running the GUI Simulator 
```bash
cd gui_simulator
```
```bash
npm install
```
### To run the development server
```bash
npm run dev
```

## 2. Usage Instructions  

### *Input File (input.mc)*  
Format:  

<PC> <Instruction>  
#Data Segment  
<Address> <Value>  


### *Output File (output.mc)*  
Format:  

Final Registers:  
R[0]: 0x00000000  
...  

Final Memory State:  
Mem[0x1000] = 0x12  
...  


---

## 3. Simulator Workflow  

The simulator executes the machine code using the five-stage RISC-V pipeline model:

1. Instruction Fetch (IF): The instruction is fetched from memory at the address stored in the Program Counter (PC). The PC is then incremented to point to the next instruction.
2. Instruction Decode (ID): The fetched instruction is decoded to determine the operation type (R, I, S, SB, U, or UJ format). The required register values and immediate values are extracted.
3. Execution (EX): The decoded instruction is executed. Arithmetic and logical operations are performed using the ALU, and branch targets are calculated if applicable.
4. Memory Access (MEM): If the instruction involves memory (load/store), memory access is performed. Load instructions fetch values from memory, while store instructions write data to memory.
5. Writeback (WB): The result of the execution (ALU result, memory read data, or immediate values) is written back to the appropriate register.

### Key Features:  
- Implements 32 registers (x0 is hardwired to 0).  
- Supports 4KB memory (0x00000000 to 0x00000FFF).  
- Efficient handling of branching instructions (BEQ, BNE, JAL, JALR).  
- Maintains clock cycle count to track execution performance.  
- Implements exception handling for illegal instructions and memory access violations.  
- Supports pipeline hazard detection and basic forwarding mechanisms.  
- Provides step-by-step logging of each instruction execution.  

---

## 4. Supported Instructions  

| Type  | Instructions |  
|-----------|------------------|  
| R-Type | add, sub, and, or, sll, srl |  
| I-Type | addi, lb, lw, jalr |  
| S-Type | sb, sw |  
| SB-Type | beq, bne |  
| U-Type | lui, auipc |  
| UJ-Type | jal |  

---

## 5. Memory & Register Handling  

### *Registers (REG[32])*  
- x0 = 0 (immutable).  
- Other registers store 32-bit values.  

### Data Segment  
- Byte-addressable memory for efficient storage.  
- Memory is dynamically allocated as needed.  
- Only modified addresses are logged to optimize output readability.  

---

## 6. Output Format  

### Registers  
plaintext
Reg[0]: 0x00000000  
Reg[1]: 0x12345678  


### Memory  
plaintext
Mem[0x1000] = 0x12  
Mem[0x1004] = 0x34  


### Clock Cycles  
plaintext
Final Clock Cycles: 42  


---

## Conclusion  
The RISC-V Simulator accurately simulates the execution of machine code, providing detailed logging of register and memory states. It integrates seamlessly with the Phase 1 Assembler for end-to-end execution of RISC-V programs.  

For any issues, check the source documentation or contact the project team. ðŸš€
